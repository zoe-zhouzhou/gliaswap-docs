(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{101:function(t,e,n){"use strict";n.r(e),n.d(e,"frontMatter",(function(){return o})),n.d(e,"metadata",(function(){return s})),n.d(e,"toc",(function(){return u})),n.d(e,"default",(function(){return l}));var a=n(3),i=n(7),_=(n(0),n(117)),o={id:"info-type-script",title:"Info Cell Type Script"},s={unversionedId:"tx-script-sudt/info-type-script",id:"tx-script-sudt/info-type-script",isDocsHomePage:!1,title:"Info Cell Type Script",description:"1. Rule 1 - TypeID rules",source:"@site/docs/tx-script-sudt/info-type-script.md",slug:"/tx-script-sudt/info-type-script",permalink:"/gliaswap-docs/docs/tx-script-sudt/info-type-script",editUrl:"https://github.com/facebook/docusaurus/edit/master/website/docs/tx-script-sudt/info-type-script.md",version:"current",sidebar:"docs",previous:{title:"Pool transaction structure",permalink:"/gliaswap-docs/docs/tx-script-sudt/pool-tx"},next:{title:"Info Cell Lock Script",permalink:"/gliaswap-docs/docs/tx-script-sudt/info-lock-script"}},u=[],r={toc:u};function l(t){var e=t.components,n=Object(i.a)(t,["components"]);return Object(_.b)("wrapper",Object(a.a)({},r,n,{components:e,mdxType:"MDXLayout"}),Object(_.b)("h4",{id:"1-rule-1---typeid-rules"},"1. Rule 1 - ",Object(_.b)("a",Object(a.a)({parentName:"h4"},{href:"https://github.com/nervosnetwork/ckb/blob/master/script/src/type_id.rs"}),"TypeID rules")),Object(_.b)("h4",{id:"2-rule-2---if-this-is-a-matching-transaction-the-cell-sequence-in-this-tx-should-follow-the-rules-blow"},"2. Rule 2 - If this is a matching transaction, the cell sequence in this tx should follow the rules blow:"),Object(_.b)("pre",null,Object(_.b)("code",Object(a.a)({parentName:"pre"},{className:"language-text"}),"\ninfo_in_cell                            info_out_cell\npool_x_in_cell                          pool_x_out_cell\npool_y_in_cell                          pool_y_out_cell\n                          -------\x3e\nmatcher_in_cell                         matcher_out_ckb_cell\n\n[swap_request_cell]                     [sudt_swapped_cell\n                                       + ckb_change_cell]\n\n[ add_liquidity_x_cell                  [sudt_lp_cell\n+ add_liquidity_y_cell                 + sudt_change_cell\n                                       + ckb_change_cell]\n\n[remove_liquidity_cell]                 [sudt_x_cell\n                                       + sudt_y_cell]\n\n")),Object(_.b)("h4",{id:"3-rule-3---intercept-the-swap-request-queue-from-inputs-and-outputs-and-for-each-request-cell\uff0cverifity-if-the-actual-pay-amount-and-receive-amount-satisfy-the-request-amount-in-swap-request-cell-and-update-the-sudt_x_reserve-and-sudt_y_reserve-for-following-verification"},"3. Rule 3 - Intercept the swap request queue from inputs and outputs, and for each request cell\uff0cverifity if the actual pay amount and receive amount satisfy the request amount in swap request cell. And update the sudt_x_reserve and sudt_y_reserve for following verification."),Object(_.b)("pre",null,Object(_.b)("code",Object(a.a)({parentName:"pre"},{}),"let info = inputs[0]\nlet pool_x = inputs[1]\nlet pool_y = inputs[2]\n\nlet sudt_x_reserve = info_in.data.sudt_x_reserve\nlet sudt_y_reserve = info_in.data.sudt_y_reserve\n\nfor (let i = 0, j = 0; i < swap_inputs.length && j < swap_outputs.length; I = i + 1, j = j+ 2)\n    let req_sudt = swap_inputs[i]\n    let sudt_out = swap_outputs[j]\n    let ckb_change = swap_outputs[j + 1]\n\n    // ## Request input cell basic verification\n    // Leave capacity verification to ckb change cell below\n    if req_sudt.data.size < 16\n        || (req_sudt.type_hash != pool_x.type_hash && req_sudt.type_hash != pool_y.type_hsh)\n        return fail\n\n    let sudt_out_type_hash = req_sudt.lock.args[0..32]\n    // Swapped sudt not match\n    if (sudt_out_type_hash != pool_x.type_hash && sudt_out_type_hash != pool_y.type_hash)\n        return fail\n\n    // Swap self\n    if sudt_out_type_hash == req_sudt.type_hash\n        return fail\n\n    // ## Output cell basic verification\n    let user_lock_hash = req_sudt.lock.args[32..64]\n    let tips_ckb = req_sudt.lock.args[81..89]\n    let tips_sudt = req_sudt.lock.args[90..105]\n\n    if sudt_out.capacity != MIN_SUDT_CAPACITY\n        || sudt_out.data.size < 16\n        || sudt_out.type_hash != sudt_out_type_hash\n        || sudt_out.lock_hash != user_lock_hash\n        return fail\n\n    if ckb_change.capacity != req_sudt.capacity - MIN_SUDT_CAPACITY - tips_ckb\n        || ckb_change.data.size != 0\n        || ckb_change.type != none\n        || ckb_change.lock_hash != user_lock_hash\n        return fail\n\n    // ## Swap price verification\n    let amount_in = req_sudt.data.amount - tips_sudt\n    let amount_out = sudt_out.data.amount\n    let amount_out_min = req_sudt.lock.args[65..81]\n\n    if amount_out_min == 0\n        || amount_out < amount_out_min\n        return fail\n\n    // sudt x => sudt y\n    if sudt_out.type_hash == pool_y.type_hash\n        let numerator = 997 * sudt_y_reserve * amount_in\n        let denominator = sudt_x_reserve * 1000 + amount_in * 997\n\n        if amount_out != (numerator / denominator) + 1\n            return fail\n\n        sudt_x_reserve = sudt_x_reserve + amount_in\n        sudt_y_reserve = sudt_y_reserve - amount_out\n    else\n        let numerator = 997 * sudt_x_reserve * amount_in\n        let denominator = sudt_y_reserve * 1000 + amount_in * 997\n\n        if amount_out != (numerator / denominator) + 1\n            return fail\n\n        sudt_x_reserve = sudt_x_reserve - amount_out\n        sudt_y_reserve = sudt_y_reserve + amount_in\n    fi\nendfor\n")),Object(_.b)("h4",{id:"4-rule-4---if-this-is-a-creating-pool-transaction-verify-that-two-pool-cells-is-created-at-the-same-time-as-the-info-cell-and-that-the-data-filled-in-info-cell-and-pool-cell-are-correct"},"4. rule 4 - If this is a creating pool transaction, verify that two Pool cells is created at the same time as the Info cell, and that the data filled in info cell and pool cell are correct."),Object(_.b)("pre",null,Object(_.b)("code",Object(a.a)({parentName:"pre"},{}),"// Info creation\nif count(input.type.code_hash == INFO_TYPE_CODE_HASH) == 0\n    && count(output.type.code_hash == INFO_TYPE_CODE_HASH) == 1\n\n    // For type deployment, the output.lock.code_hash is info lock dep cell's\n    // type hash. So we must extract data hash from dep cell to be able to\n    // verify it agains our hard code data hash, INFO_LOCK_CODE_HASH.\n    if not_find(any(cell_dep).type_hash == output.lock.code_hash)\n        return fail\n    let info_lock_data_hash = hash(info_lock_cell_dep.data)\n    let lock_count = count(info_lock_data_hash == INFO_LOCK_CODE_HASH)\n\n    if lock_count == 3 // sudt/sudt\n        let pool_x = outputs[1]\n        let pool_y = outputs[2]\n\n        // Same sudt\n        if pool_x.type_hash == pool_y.type_hash\n            return fail\n\n        if info.lock.hash_type != 1\n            || info.lock.args[0..32] != hash(pool_x.type_hash | pool_y.type_hash)\n            || info.lock.args[32..64] != info.type_hash\n            return fail\n\n        if pool_x.capacity != POOL_BASE_CAPACITY\n            || pool_x.data.size < 16\n            || pool_x.lock_hash != info.lock_hash\n            || pool_y.capacity != POOL_BASE_CAPACITY\n            || pool_y.data.size < 16\n            || pool_y.lock_hash != pool_x.lock_hash\n            return fail\n    else\n        return fail\nfi\n")),Object(_.b)("h4",{id:"5-rule-5---if-this-is-initially-adding-liquidity-verify-if-minting-the-correct-amount-liquidity-token-for-user-and-verify-if-the-data-storaged-in-info-cell-and-pool-cell-is-correct"},"5. Rule 5 - If this is initially adding liquidity, verify if minting the correct amount Liquidity token for user, and verify if the data storaged in info cell and pool cell is correct."),Object(_.b)("pre",null,Object(_.b)("code",Object(a.a)({parentName:"pre"},{}),"\nlet info = inputs[0]\nlet pool_x = inputs[1]\nlet pool_y = inputs[2]\n\nlet sudt_x_reserve = swap_updated_sudt_x_reserve\nlet sudt_y_reserve = swap_updated_sudt_y_reserve\nlet total_liquidity = info_in.data.total_liquidity\n\nfn verify_genesis_liquidity()\n    // Wrong cell number\n    if inputs.len() != 6 || outputs.len() != 6\n        return fail\n\n    // Not genesis\n    if sudt_x_reserve != 0\n        || sudt_y_reserve != 0\n        || total_liquidity != 0\n        return fail\n\n    let req_sudt_x = inputs[4]\n    let req_sudt_y = inputs[5]\n    let sudt_lp = outputs[4]\n    let ckb_change = outputs[5]\n\n    // ## Request input cell basic verification\n    // Capacity verification is done by output ckb change cell below\n    if req_sudt_x.data.size < 16\n        || req_sudt_x.type_hash != pool_x.type_hash\n        || req_sudt_y.data.size < 16\n        || req_sudt_y.type_hash != pool_y.type_hash\n        return fail\n\n    // Info cell not match\n    if req_sudt_x.lock.args[0..32] != info.type_hash\n        || req_sudt_y.lock.args[0..32] != info.type_hash\n        return fail\n\n    // Req user lock hash not match\n    let user_lock_hash = req_sudt_x.lock.args[32..64]\n    if req_sudt_y.lock.args[32..64] != user_lock_hash\n        return fail\n\n    // Req cell not match\n    if req_sudt_y.lock.args[64..96] != req_sudt_x.lock_hash\n        return fail\n\n    // ## Output cell basic verification\n    let tips_ckb = req_sudt_x.lock.args[97..105]\n    let tips_sudt_x = req_sudt_x.lock.args[105..121]\n    let tips_sudt_y = req_sudt_x.lock.args[121..137]\n\n    if sudt_lp.capacity != MIN_SUDT_CAPACITY\n        || sudt_lp.data.size < 16\n        || sudt_lp.type_hash != info.data.sudt_lp_type_hash\n        || sudt_lp.lock_hash != user_lock_hash\n        reutrn fail\n\n    if ckb_change.capacity != req_sudt_x.capacity + req_sudt_y.capacity - MIN_SUDT_CAPACITY - tips_ckb\n        || ckb_change.data.size != 0\n        || ckb_change.type != none\n        || ckb_change.lock_hash != user_lock_hash\n        return fail\n\n    // ## Genesis liquidity price verification\n    let amount_x_in = req_sudt_x.data.amount - tips_sudt_x\n    let amount_y_in = req_sudt_y.data.amount - tips_sudt_y\n    let amount_lp = sudt_lp.data.amount\n\n    if amount_lp != (amount_x_in * amount_y_in).sqrt();\n        return fail\n\n    sudt_x_reserve = amount_x_in\n    sudt_y_reserve = amount_y_in\n    total_liquidity = amount_lp\nendfn\n\n")),Object(_.b)("p",null,Object(_.b)("strong",{parentName:"p"},"6. rule 6 - Intercept the liquidity request queue from inputs and outputs, and for each request cell\uff0cverifity if the actual pay amount and receive amount satisfy the request amount in the request cell. And update the sudt_x_reserve and sudt_y_reserve for following verification.")),Object(_.b)("ul",null,Object(_.b)("li",{parentName:"ul"},"If it is add liquidity request cell, verify if minting the correct amount Liquidity token for user, and add up the CKB amount, sUDT amount and Liquidity token amount for verifying info cell and pool cell later."),Object(_.b)("li",{parentName:"ul"},"If it is remove liquidity request cell, verify if withdraw the correct CKB amount and sudt amount for user, update the CKB amount, sUDT amount and Liquidity token amount for verifying info cell and pool cell later."),Object(_.b)("li",{parentName:"ul"},"Verify if the data changed in info cell and pool cell is correct ")),Object(_.b)("pre",null,Object(_.b)("code",Object(a.a)({parentName:"pre"},{}),"// verify add liquidity request\nfn verify_add_liquidity()\n    // Wait genesis liquidity\n    if total_liquidity == 0\n        return fail\n\n    for(let i = 0, j = 0; i < add_inputs.length && j < add_inputs.length, i = i + 2, j = j + 3)\n        let req_sudt_x = add_inputs[i]\n        let req_sudt_y = add_inputs[i + 1]\n        let sudt_lp = add_outputs[j]\n        let sudt_change = add_outputs[j + 1]\n        let ckb_change = add_outputs[j + 2]\n\n        // ## Request input cell basic verification\n        // Capacity verification is done by output ckb change cell below\n        if req_sudt_x.data.size < 16\n            || req_sudt_x.type_hash != pool_x.type_hash\n            || req_sudt_y.data.size < 16\n            || req_sudt_y.type_hash != pool_y.type_hash\n            return fail\n\n        // info cell not match\n        if req_sudt_x.lock_hash[0..32] != info.type_hash\n            || req_sudt_y.lock_hash[0..32] != info.type_hash\n            return fail\n\n        // Req use lock hash not match\n        let user_lock_hash = req_sudt_x.lock.args[32..64]\n        if req_sudt_y.lock.args[32..64] != user_lock_hash\n            return fail\n\n        // req cell not match\n        if req_sudt_y.lock.args[64..96] != req_sudt_x.lock_hash\n            return fail\n\n        // ## Output cell basic verification\n        let tips_ckb = req_sudt_x.lock.args[97..105]\n        let tips_sudt_x = req_sudt_x.lock.args[105..121]\n        let tips_sudt_y = req_sudt_y.lock.args[121..137]\n\n        if sudt_lp.capacity != MIN_SUDT_CAPACITY\n            || sudt_lp.data.size < 16\n            || sudt_lp.type_hash != info.data.sudt_lp_type_hash\n            || sudt_lp.lock_hash != user_lock_hash\n            reutrn fail\n\n        if sudt_change.capacity != MIN_SUDT_CAPACITY\n            || sudt_change.data.size < 16\n            || (sudt_change.type_hash != req_sudt_x.type_hash && sudt_change != req_sudt_y.type_hash)\n            || sudt_change.lock_hash != user_lock_hash\n            return fail\n\n        if ckb_change.capacity != req_sudt_x.capacity + req_sudt_y.capacity - 2 * MIN_SUDT_CAPACITY - tips_ckb\n            || ckb_change.data.size != 0\n            || ckb_change.type != none\n            || ckb_change.lock_hash != user_lock_hash\n            return fail\n\n        // ## Add liquidity price verification\n        let amount_x = req_sudt_x.data.amount - tips_sudt_x\n        let amount_y = req_sudt_y.data.amount - tips_sudt_y\n        let amount_x_min = req_sudt_x.lock.args[65..81]\n        let amount_y_min = req_sudt_y.lock.args[81..97]\n        let amount_change = sudt_change.data.amount\n        let amount_lp = sudt_lp.data.amount\n\n        // Check sudt x exhaustion\n        if sudt_change.type_hash == req_sudt_y.type_hash\n            let amount_y_in = amount_y - amount_change\n            if amount_y_min == 0 || amount_y_in < amount_y_min\n                return fail\n\n            if amount_y_in != (amount_x * sudt_y_reserve / sudt_x_reserve) + 1\n                return fail\n\n            if amount_lp != amount_x * total_liquidity / sudt_x_reserve + 1\n                return fail\n\n            sudt_x_reserve = sudt_x_reserve + amount_x\n            sudt_y_reserve = sudt_y_reserve + amount_y_in\n\n        // Check sudt y exhaustion\n        else\n            let amount_x_in = amount_x - amount_change\n            if amount_x_min == 0 || amount_x_in < amount_x_min\n                return fail\n\n            if amount_x_in != (amount_y * sudt_x_reserve / sudt_y_reserve) + 1\n                return fail\n\n            if amount_lp != amount_y * total_liquidity / sudt_y_reserve + 1\n                return fail\n\n            sudt_x_reserve = sudt_x_reserve + amount_x_in\n            sudt_y_reserve = sudt_y_reserve + amount_y\n        fi\n\n        total_liquidity = total_liquidity + amount_lp\n    endfor\nendfn\n")),Object(_.b)("pre",null,Object(_.b)("code",Object(a.a)({parentName:"pre"},{}),"//verify remove liquidity request\nfn verify_remove_liquidity()\n    // Wait genesis liquidity\n    if total_liquidity == 0\n        return fail\n\n    for(let i = 0, j = 0; i < remove_inputs.length && j < remove_inputs.length, i = i + 1, j = j + 2)\n        let req_sudt_lp = remove_inputs[i]\n        let sudt_x = remove_outputs[j]\n        let sudt_y = remove_outputs[j + 1]\n\n        // ## Request input cell basic verification\n        if req_sudt_lp.capacity < MIN_SUDT_CAPACITY * 2\n            || req_sudt_lp.data.size < 16\n            return fail\n\n        // info cell sudt type hash not match\n        if req_sudt_lp.type_hash != info.data.sudt_lp_type_hash\n            return fail\n\n        // info cell not match\n        if req_sudt_lp.lock_hash[0..32] != info.type_hash\n            return fail\n\n        // ## Output cell basic verification\n        let user_lock_hash = req_sudt_lp.lock.args[32..64]\n        let tips_sudt_lp = req_sudt_lp.lock.args[105..121]\n\n        if sudt_x.capacity != MIN_SUDT_CAPACITY\n            || sudt_x.data.size < 16\n            || sudt_x.type_hash != pool_x.type_hash\n            || sudt_x.lock_hash != user_lock_hash\n            return fail\n\n        if sudt_y.capacity != MIN_SUDT_CAPACITY\n            || sudt_y.data.size < 16\n            || sudt_y.type_hash != pool_y.type_hash\n            || sudt_y.lock_hash != user_lock_hash\n            return fail\n\n        // ## Remove liquidity price verification\n        let amount_lp = req_sudt_lp.data.amount - tips_sudt_lp\n        let amount_x_out = sudt_x.data.amount\n        let amount_y_out = sudt_y.data.amount\n        let amount_x_out_min = sudt_x.lock.args[65..81]\n        let amount_y_out_min = sudt_y.lock.args[81..97]\n\n        if amount_x_out_min == 0\n            || amount_x_out < amount_x_out_min\n            return fail\n\n        if amount_y_out_min == 0\n            || amount_y_out < amount_y_out_min\n            return fail\n\n        if amount_x_out != amount_lp * sudt_x_reserve / total_liquidity + 1\n            return fail\n\n        if amount_y_out != amount_lp * sudt_y_reserve / total_liquidity + 1\n            return fail\n\n        sudt_x_reserve = sudt_x_reserve - amount_x_out\n        sudt_y_reserve = sudt_y_reserve - amount_y_out\n    endfor\nendfn\n")),Object(_.b)("pre",null,Object(_.b)("code",Object(a.a)({parentName:"pre"},{}),"// Verify if the data changed in info cell and pool cell is correct \nif info_creation?\n    return info_creation_verification()\nfi\n\nlet info_in = inputs[0]\nlet pool_x_in = inputs[1]\nlet pool_y_in = inputs[2]\n\nlet info_out = outputs[0]\nlet pool_x_out = outputs[1]\nlet pool_y_out = outputs[2]\n\n// ## Input info, pool basic verification\n// Leave info type hash verification to outputs below\nif info_in.capacity != INFO_CAPACITY\n    || info_in.data.size != 80\n    || info_in.data.sudt_x_reserve != pool_x_in.data.amount\n    || info_in.data.sudt_y_reserve != pool_y_in.data.amount\n    || info_in.lock.args[0..32] != hash(pool_x_in.type_hash | pool_y_in.type_hash)\n    || info_in.lock.args[32..64] != info.type_hash\n    return fail\n\n// poox_x_in type hash is alredy verified above\nif pool_x_in.capacity != POOL_CAPACITY\n    || pool_x_in.data.size < 16\n    || pool_x_in.lock_hash != info_in.lock_hash\n    return fail\n\n// poox_y_in type hash is alredy verified above\nif pool_y_in.capacity != POOL_CAPACITY\n    || pool_y_in.data.size < 16\n    || pool_y_in.lock_hash != info_in.lock_hash\n    return fail\n\n// ## Output info, pool basic verification\nif info_out.capacity != info_in.capacity\n    || info_out.data.size != info_out.data.size\n    || info_out.data.sudt_x_reserve != pool_x_out.data.amount\n    || info_out.data.sudt_y_reserve != pool_y_out.data.amount\n    || info_out.type_hash != info_in.type_hash\n    || info_out.lock_hash != info_out.lock_hash\n    return fail\n\nif pool_x_out.capacity != pool_x_in.capacity\n    || pool_x_out.data.size != pool_x_in.data.size\n    || pool_x_out.type_hash != pool_x_in.type_hash\n    || pool_x_out.lock_hash != pool_x_in.lock_hash\n    return fail\n\nif pool_y_out.capacity != pool_y_in.capacity\n    || pool_y_out.data.size != pool_y_in.data.size\n    || pool_y_out.type_hash != pool_y_in.type_hash\n    || pool_y_out.lock_hash != pool_y_in.lock_hash\n    return fail\n\n// ## Transaction verification\nlet sudt_x_reserve = info_in.data.sudt_x_reserve\nlet sudt_y_reserve = info_in.data.sudt_y_reserve\nlet total_liquidity = info_in.data.total_liquidity\n\nlet swap_size = WitnessArgs.type_input.swap_size\nlet add_liquidity_size = WitnessArgs.type_input.add_liquidity_size\n\nlet swap_inputs = inputs[4..4 + swap_size]\nlet swap_outputs = outputs[4..4 + swap_size * 2]\ndo_swap_verification(swap_inputs, swap_outputs, sudt_x_reserve, sudt_y_reserve)\n\nlet add_inputs = inputs[4 + swap_size..4 + swap_size + add_size * 2]\nlet add_ouputs = outpus[4 + swap_size * 2.. 4 + swap_size * 2 + add_size * 3]\ndo_add_liquidity_verification(add_inputs, add_ouputs, sudt_x_reserve, sudt_y_reserve, total_liquidity)\n\nlet remove_inputs = inputs[4 + swap_size + add_size * 2..]\nlet remove_ouputs = outputs[4 + swap_size * 2 + add_size * 3..]\ndo_remove_liquidity_verification(remove_inputs, remove_outputs, sudt_x_reserve, sudt_y_reserve, total_liquidity)\n\nif sudt_x_reserve != info_out.data.sudt_x_reserve\n    || sudt_y_reserve != info_out.data.sudt_y_reserve\n    || total_liquidity != info_out.data.total_liquidity\n    return fail\n")))}l.isMDXComponent=!0},117:function(t,e,n){"use strict";n.d(e,"a",(function(){return c})),n.d(e,"b",(function(){return h}));var a=n(0),i=n.n(a);function _(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function o(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,a)}return n}function s(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?o(Object(n),!0).forEach((function(e){_(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function u(t,e){if(null==t)return{};var n,a,i=function(t,e){if(null==t)return{};var n,a,i={},_=Object.keys(t);for(a=0;a<_.length;a++)n=_[a],e.indexOf(n)>=0||(i[n]=t[n]);return i}(t,e);if(Object.getOwnPropertySymbols){var _=Object.getOwnPropertySymbols(t);for(a=0;a<_.length;a++)n=_[a],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(i[n]=t[n])}return i}var r=i.a.createContext({}),l=function(t){var e=i.a.useContext(r),n=e;return t&&(n="function"==typeof t?t(e):s(s({},e),t)),n},c=function(t){var e=l(t.components);return i.a.createElement(r.Provider,{value:e},t.children)},d={inlineCode:"code",wrapper:function(t){var e=t.children;return i.a.createElement(i.a.Fragment,{},e)}},p=i.a.forwardRef((function(t,e){var n=t.components,a=t.mdxType,_=t.originalType,o=t.parentName,r=u(t,["components","mdxType","originalType","parentName"]),c=l(n),p=a,h=c["".concat(o,".").concat(p)]||c[p]||d[p]||_;return n?i.a.createElement(h,s(s({ref:e},r),{},{components:n})):i.a.createElement(h,s({ref:e},r))}));function h(t,e){var n=arguments,a=e&&e.mdxType;if("string"==typeof t||a){var _=n.length,o=new Array(_);o[0]=p;var s={};for(var u in e)hasOwnProperty.call(e,u)&&(s[u]=e[u]);s.originalType=t,s.mdxType="string"==typeof t?t:a,o[1]=s;for(var r=2;r<_;r++)o[r]=n[r];return i.a.createElement.apply(null,o)}return i.a.createElement.apply(null,n)}p.displayName="MDXCreateElement"}}]);