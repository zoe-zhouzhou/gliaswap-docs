(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{106:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return _}));var a=n(0),r=n.n(a);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=r.a.createContext({}),u=function(e){var t=r.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=u(e.components);return r.a.createElement(c.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},d=r.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,s=e.originalType,o=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),p=u(n),d=a,_=p["".concat(o,".").concat(d)]||p[d]||b[d]||s;return n?r.a.createElement(_,i(i({ref:t},c),{},{components:n})):r.a.createElement(_,i({ref:t},c))}));function _(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var s=n.length,o=new Array(s);o[0]=d;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:a,o[1]=i;for(var c=2;c<s;c++)o[c]=n[c];return r.a.createElement.apply(null,o)}return r.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},86:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return i})),n.d(t,"toc",(function(){return l})),n.d(t,"default",(function(){return u}));var a=n(3),r=n(7),s=(n(0),n(106)),o={id:"swap-tx",sidebar_label:"Swap",title:"Swap Transaction Structure"},i={unversionedId:"tx-script/swap-tx",id:"tx-script/swap-tx",isDocsHomePage:!1,title:"Swap Transaction Structure",description:"A swap operation might be involved in 3 transactions:",source:"@site/docs/tx-script/swap-tx.md",slug:"/tx-script/swap-tx",permalink:"/gliaswap-docs/docs/tx-script/swap-tx",editUrl:"https://github.com/facebook/docusaurus/edit/master/website/docs/tx-script/swap-tx.md",version:"current",sidebar_label:"Swap",sidebar:"docs",previous:{title:"Cell Structure",permalink:"/gliaswap-docs/docs/tx-script/cell"},next:{title:"Pool transaction structure",permalink:"/gliaswap-docs/docs/tx-script/pool-tx"}},l=[{value:"1. Traders submit swap request",id:"1-traders-submit-swap-request",children:[]},{value:"2. Deal-miners match swap request with pool cells",id:"2-deal-miners-match-swap-request-with-pool-cells",children:[{value:"Swap request lock script",id:"swap-request-lock-script",children:[]},{value:"Info type script",id:"info-type-script",children:[]},{value:"Info lock script",id:"info-lock-script",children:[]}]},{value:"3. Traders can cancel their own swap request",id:"3-traders-can-cancel-their-own-swap-request",children:[{value:"Swap request lock script",id:"swap-request-lock-script-1",children:[]}]}],c={toc:l};function u(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(s.b)("wrapper",Object(a.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(s.b)("p",null,"A swap operation might be involved in 3 transactions:"),Object(s.b)("ol",null,Object(s.b)("li",{parentName:"ol"},"Traders submit swap request"),Object(s.b)("li",{parentName:"ol"},"Aggregators match swap request with pool to help traders to complete swap"),Object(s.b)("li",{parentName:"ol"},"Traders cancel swap request")),Object(s.b)("h2",{id:"1-traders-submit-swap-request"},"1. Traders submit swap request"),Object(s.b)("p",null,"(1) When using CKB to buy sUDT,  a swap request transaction may looks like the following:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{}),"Inputs:\n    User's Normal cell\n        Capacity:\n             <X + 146 + tx fee>\n        Data:\n            null\n        Type\n            null\n        Lock\n            <user's lock>\n        \nOutputs:\n    Swap Request Cell\n        Capacity:\n             <X + 146>\n        Data:\n            null\n        Type:\n            null \n        Lock:\n            code_hash: order lock script\n            args: user_lock_hash | version | min_amount_out: Y | sudt_type_hash | 0 | 0|\n")),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},"X = Pay is the CKB amount users need to pay, including the 0.3% trading fees"),Object(s.b)("li",{parentName:"ul"},"Y = Receive(1-s) is the sUDT minimum amount user will receive. s is the sliapage rate users set by themselves."),Object(s.b)("li",{parentName:"ul"},"They satisfy this formula: Receive = 997 ",Object(s.b)("em",{parentName:"li"}," Pay ")," Rr/ (997 ",Object(s.b)("em",{parentName:"li"}," Pay + 1000 ")," Pr)\uff0cRr is Receive asset reserve \uff0cPr is Pay asset reserve \u3002")),Object(s.b)("p",null,"(2) When using Y sUDT to buy X CKB at P price, a swap request transaction may looks like the following:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{}),"Inputs:\n    User's Normal cell\n        Capacity:\n            <227 + tx fee>\n        Data:\n            sudt_amount: <Y>\n        Type\n            <sUDT type>\n        Lock\n            <user's lock>\n            \nOutputs:\n    Swap Request Cell:\n        Capacity:\n            <227>\n        Data:\n            sudt_amount: <Y> \n        Type:\n            <sUDT type> \n        Lock:\n            code_hash: SWAP_ORDER_CODE_HASH\n            args: user_lock_hash | version | min_amount_out: X | byte32(0x00) | 0 | 0|\n")),Object(s.b)("ul",null,Object(s.b)("li",{parentName:"ul"},"Y is the sUDT amount users need to pay containing the 0.3% trading fees"),Object(s.b)("li",{parentName:"ul"},"X = Receive(1-s) is the CKB amount user will receive. s is the sliapage rate."),Object(s.b)("li",{parentName:"ul"},"They satisfy this formula: Receive = 997 ",Object(s.b)("em",{parentName:"li"}," Pay ")," Rr / (997 ",Object(s.b)("em",{parentName:"li"}," Pay + 1000 ")," Pr)\uff0cRr is Receive asset reserve \uff0cPr is Pay asset reserve \u3002")),Object(s.b)("p",null,"Notice that the swap request transaction only validates regular SUDT rules constrained in sudt type script."),Object(s.b)("h2",{id:"2-deal-miners-match-swap-request-with-pool-cells"},"2. Deal-miners match swap request with pool cells"),Object(s.b)("p",null,"After traders submit the swap request, Aggregators will help traders to complete the swap. Motivated by the Tip fee claimed in the swap request cell (tip fee currently is 0), aggregators will continually retrieve the swap request cells and the pool cells on chain and then compete to match them off-chain and submit matching transactions. We open sourced a simple aggregators software for basic use. Information on how to deploy it can be found on ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/glias/glia-swap-matcher"}),"GitHub"),". This software is a starting point for you to develop your own solution. You can maximize earnings by identifying and implementing your optimization strategies."),Object(s.b)("p",null,"The matching transaction may looks like:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{}),"Input\n    Info cell\n        capacity: \n            250\n        data: \n            ckb_reserve: M\n            sudt_reserve: N\n            LP_token_balance: L\n            LP_type_hash\n        type: \n            code_hash: INFO_TYPE_CODE_HASH \n            args: type id \n        lock: \n            code_hash: INFO_LOCK_CODE_HASH \n            args: hash(ckb | asset_sudt_type_hash) | info_type_hash\n                \n     Pool cell\n        capacity: \n            186 + M\n        data: \n            sudt_amount: N\n        type: \n            <sudt type> \n        lock: \n            <info lock> \n    \n     Aggregator cell\n     \n     Bob swap request cell_00\n        Capacity\n        Data:\n            sudt_amount \n        Type:\n            <sUDT type> \n        Lock:\n            code_hash: SWAP_ORDER_CODE_HASH\n            args: user_lock_hash | version | amount_in | min_amount_out | order_type: 00\n\n        \n     Alice swap request cell_00  \n\nOutput\n    Info cell\n        capacity: \n            250\n        data: \n            ckb_reserve: M2\n            sudt_reserve: N2\n            lp_token_balance: L\n            lp_token_type_hash\n        type: \n            code_hash: Info_TYPE_CODE_HASH \n            args: type id \n        lock: \n            code_hash: INFO_LOCK_CODE_HASH \n            args: hash(ckb | asset_sudt_type_hash) | info_type_hash\n                \n     Pool cell\n        capacity: \n            186 + M2\n        data: \n            sudt_amount: N2\n        type: \n            <sudt type> \n        lock: \n            <info cell lock> \n    \n     Aggregator cell\n     \n     Bob normal cell\n        Capacity\n        Data:\n            sudt_amount \n        Type:\n            <sUDT type> \n        Lock:\n            <user normal lock>\n  \n     Alice normal cell \n")),Object(s.b)("p",null,"In this transaction, three types of script will be run to verify the tx:"),Object(s.b)("h3",{id:"swap-request-lock-script"},"Swap request lock script"),Object(s.b)("p",null,Object(s.b)("strong",{parentName:"p"},"Rule 1 - verifity if the actual pay amount and receive amount satisfy the request amount in swap request cell.")),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{}),"let pool = inputs[1]\nfor order in group_inputs[..] // QueryIter::new(load_input, Source::GroupInput).collect()\n  let order = inputs[order_index_in_inputs]\n  let output = outputs[order_index_in_inputs]\n\n  let user_lock_hash = order.lock.args[0..32]\n  let amount_in = BigUint::from(order.lock.args[33..49])\n  let min_amount_out = BigUint::from(order.lock.args[49..65])\n  let order_type = order.lcok.args[65..66]\n\n  if output.lock_hash != user_lock_hash\n      return fail\n  if amount_in == 0\n      return fail\n\n  if order_type == SellCKB\n      if output.type_hash != pool.type_hash\n          return fail\n\n      if order.capacity <= output.capacity\n          || order.capacity - output.capacity != amount_in\n          return fail\n\n      if output.data.sudt_amount < min_amount_out\n          return fail\n  else if order_type == BuyCKB\n      if output.type_hash.is_some()\n          return fail\n\n      if output.capacity < order.capacity + min_amount_out\n          return fail\n\n      if output.data.size != 0\n          return fail\n  else\n      return fail\n  fi\nendfor\n")),Object(s.b)("h3",{id:"info-type-script"},"Info type script"),Object(s.b)("p",null,Object(s.b)("strong",{parentName:"p"},"Rule 1 - ",Object(s.b)("a",Object(a.a)({parentName:"strong"},{href:"https://github.com/nervosnetwork/ckb/blob/master/script/src/type_id.rs"}),"TypeID rules"))),Object(s.b)("p",null,Object(s.b)("strong",{parentName:"p"},"Rule 2 - If this is a matching swap transaction, the cell sequence in this tx should follow the rules blow:")),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-text"}),"\ninfo_in_cell                            info_out_cell\npool_in_cell                            pool_out_cell\n                          -------\x3e\nmatcher_in_cell                         matcher_out_cell\n[swap_request_cell]                     [sudt_cell\u6216\u8005ckb_cell]\n\n")),Object(s.b)("p",null,Object(s.b)("strong",{parentName:"p"},"Rule 3 - If this is a swap matching transaction, verify whether the data changes in the info cell is correct and corresponding to the actual increase or decrease in the amount of assets in the pool cell")),Object(s.b)("p",null,"Notice\uff1aIn pseudo code blow\uff0ctotal_liqidity is the LP token balance in info cell, and liquidity_sudt_type_hash is LP token type hash."),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{}),"let info_in = inputs[0]\nlet pool_in = inputs[1]\nlet info_out = outputs[0]\nlet pool_out = outputs[1]\n\nif info_out.capacity != INFO_CAPACITY\n    || info_out.data.total_liquidity != info_in.data.total_liquidity\n    return fail\n\nlet ckb_got = BigInt::from(info_out.data.ckb_reserve) - info_in.data.ckb_reserve\nlet sudt_got = BigInt::from(info_out.data.sudt_reserve) - info_in.data.sudt_reserve\n\nlet ckb_reserve = info_in.data.ckb_reserve\nlet sudt_reserve = info_in.data.sudt_reserve\n\nif ckb_got > 0 && sudt_got < 0 // tx buy sudt\n    let sudt_paid = info_in.data.sudt_reserve - info_out.data.sudt_reserve\n\n    if ckb_got != (1000 * ckb_reserve * sudt_paid) / (997 * (sudt_reserve - sudt_paid))\n        return fail\nelse if ckb_got < 0 && sudt_got > 0 // tx sell sudt\n    let ckb_paid = info_in.data.ckb_reserve - info_out.data.ckb_reserve\n\n    if sudt_got != (1000 * sudt_reserve * ckb_paid) / (997 * (ckb_reserve - ckb_paid))\n        return fail\nelse\n    return fail\nfi\n\nif pool_out.capacity != pool_in.capacity + ckb_got\n    || pool_out.data.amount != pool_in.data.amount + sudt_got\n    return fail\n\nreturn success\n")),Object(s.b)("h3",{id:"info-lock-script"},"Info lock script"),Object(s.b)("p",null,Object(s.b)("strong",{parentName:"p"},"Rules 1 - Verify if lock.args is consistent with info type")),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{}),"if count(self.lock.group_inputs) != 2\n    return fail\n\nlet info = group_inputs[0]\nlet pool = group_inputs[1]\nif hash(ckb | pool.type_hash) != self.lock.args[0..32]\n    || info.type_hash != self.lock.args[32..64]\n    return fail\n\nreturn success\n")),Object(s.b)("h2",{id:"3-traders-can-cancel-their-own-swap-request"},"3. Traders can cancel their own swap request"),Object(s.b)("p",null,"Normally your will swap successfully soon after you submit the swap request, but if the price fluctuates above the slippage, your request will be pending until the pool price fluctuates back to the price you submitted."),Object(s.b)("p",null,"So we provide the cancel option for traders. Traders can send a transaction to cancel their own liquidity request."),Object(s.b)("p",null,"For example, if Alice want to cancel his swap request:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{}),"Inputs:\n    Swap request cell:\n        Capacity:\n             <X + 146>\n        Data:\n            null\n        Type:\n            null \n        Lock:\n            code_hash: order lock script\n            args: Alice_lock_hash | version | min_amount_out: Y | sudt_type_hash | 0 | 0|\n    Alice Normal cell(used to pay the tx fee)\n\nOutputs:\n    Alice's Normal cell\n        Capacity:\n             <X + 146>\n        Data:\n            null\n        Type\n            null\n        Lock\n            <Alice's lock>\n")),Object(s.b)("p",null,"This transaction leads to another rule of swap request lock script"),Object(s.b)("h3",{id:"swap-request-lock-script-1"},"Swap request lock script"),Object(s.b)("p",null,Object(s.b)("strong",{parentName:"p"},"Rule2 - If one of input cell in the transaction use user's lock specified in liquidity request cell args and the corresponding witness is not 0, unlock the request cell directly.")),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{}),"let user_lock_hash = self.lock.args[0..32]\nif one_of(input.lock_hash) == user_lock_hash\n    // Check witness for anyone can pay lock compatibility\n    let witness = load_witness_args(this_lock_index, Source::Input).unwrap()\n    if witness.total_size() != 0\n        return success\n")))}u.isMDXComponent=!0}}]);