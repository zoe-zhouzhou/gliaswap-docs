(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{107:function(e,t,i){"use strict";i.d(t,"a",(function(){return p})),i.d(t,"b",(function(){return m}));var n=i(0),a=i.n(n);function l(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}function r(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n)}return i}function o(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?r(Object(i),!0).forEach((function(t){l(e,t,i[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):r(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}function b(e,t){if(null==e)return{};var i,n,a=function(e,t){if(null==e)return{};var i,n,a={},l=Object.keys(e);for(n=0;n<l.length;n++)i=l[n],t.indexOf(i)>=0||(a[i]=e[i]);return a}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)i=l[n],t.indexOf(i)>=0||Object.prototype.propertyIsEnumerable.call(e,i)&&(a[i]=e[i])}return a}var c=a.a.createContext({}),s=function(e){var t=a.a.useContext(c),i=t;return e&&(i="function"==typeof e?e(t):o(o({},t),e)),i},p=function(e){var t=s(e.components);return a.a.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},d=a.a.forwardRef((function(e,t){var i=e.components,n=e.mdxType,l=e.originalType,r=e.parentName,c=b(e,["components","mdxType","originalType","parentName"]),p=s(i),d=n,m=p["".concat(r,".").concat(d)]||p[d]||u[d]||l;return i?a.a.createElement(m,o(o({ref:t},c),{},{components:i})):a.a.createElement(m,o({ref:t},c))}));function m(e,t){var i=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var l=i.length,r=new Array(l);r[0]=d;var o={};for(var b in t)hasOwnProperty.call(t,b)&&(o[b]=t[b]);o.originalType=e,o.mdxType="string"==typeof e?e:n,r[1]=o;for(var c=2;c<l;c++)r[c]=i[c];return a.a.createElement.apply(null,r)}return a.a.createElement.apply(null,i)}d.displayName="MDXCreateElement"},93:function(e,t,i){"use strict";i.r(t),i.d(t,"frontMatter",(function(){return r})),i.d(t,"metadata",(function(){return o})),i.d(t,"toc",(function(){return b})),i.d(t,"default",(function(){return s}));var n=i(3),a=i(7),l=(i(0),i(107)),r={id:"cell",title:"Cell Structure"},o={unversionedId:"tx-script/cell",id:"tx-script/cell",isDocsHomePage:!1,title:"Cell Structure",description:"Gliaswap support swap and pool by specifing several cell formats and implementing a set of scripts.",source:"@site/docs/tx-script/cell.md",slug:"/tx-script/cell",permalink:"/gliaswap-docs/docs/tx-script/cell",editUrl:"https://github.com/facebook/docusaurus/edit/master/website/docs/tx-script/cell.md",version:"current",sidebar:"docs",previous:{title:"Fee Structure",permalink:"/gliaswap-docs/docs/product/fee"},next:{title:"Swap Transaction Structure",permalink:"/gliaswap-docs/docs/tx-script/swap-tx"}},b=[{value:"Swap Request Cell",id:"swap-request-cell",children:[]},{value:"Liquidity Request Cell",id:"liquidity-request-cell",children:[]},{value:"Info Cell",id:"info-cell",children:[]},{value:"Pool Cell",id:"pool-cell",children:[]},{value:"Liquidty Token Cell",id:"liquidty-token-cell",children:[]}],c={toc:b};function s(e){var t=e.components,i=Object(a.a)(e,["components"]);return Object(l.b)("wrapper",Object(n.a)({},c,i,{components:t,mdxType:"MDXLayout"}),Object(l.b)("p",null,"Gliaswap support swap and pool by specifing several cell formats and implementing a set of scripts."),Object(l.b)("p",null,"As mentioned in Gliaswap overview, traders and Lps all need to submit request firstly, and then aggregator can help them to complete swap or manage liquidity."),Object(l.b)("p",null,"A request in Gliaswap actually is a live cell on chain which also can be thought of as a data package that signals what you want to do. And an request cell is identified and constrained by the its lock. There are two types of request cell:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("p",{parentName:"li"},Object(l.b)("strong",{parentName:"p"},"Swap Request Cell"),": when swapping between CKB and sUDT, LPs need to make a request first by creating a swap request cell. This request cell signals what you want to trade, for what token, and how much you want. More details can refer to the following swap request cell format part. ")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("p",{parentName:"li"},Object(l.b)("strong",{parentName:"p"},"Liquidity Request Cell"),": when adding liquidity or removing liquidity from the pool, LPs need to make a request first by creating a liquidity request cell. This request cell signals what token pair you want to supply, for which pool, how much you want to supply. More details can refer to the following liquidity request cell format part. "))),Object(l.b)("p",null,"A pool of one token pair in Gliaswap actually is two cells on chain - info cell and pool cell. "),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"The ",Object(l.b)("strong",{parentName:"li"},"info cell")," is used to store the global states of this pool and restrict the rules for changing the status information. "),Object(l.b)("li",{parentName:"ul"},"The ",Object(l.b)("strong",{parentName:"li"},"pool cell")," is used to store the real tokens. "),Object(l.b)("li",{parentName:"ul"},"These two cell have the same lock script and different type script, and more details can refer to the following info cell and pool cell format part. ")),Object(l.b)("p",null,"Liquidity tokens are minted to track the relative proportion of total reserves that each liquidity provider has contributed. In gliaswap, liquidity token followed sUDT standard and use info lock as its owner lock. More details can refer to the following ",Object(l.b)("strong",{parentName:"p"},"liquidity token cell")," format part. "),Object(l.b)("h2",{id:"swap-request-cell"},"Swap Request Cell"),Object(l.b)("p",null,"Swap request cell is used for selling or buying assets."),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{}),'{\n  "capacity": -,\n  "data": sudt_amount,\n  "type": asset_sudt_type or liquidity_sudt_type,\n  "lock": {\n    "code_hash": SWAP_REQ_LOCK_CODE_HASH,\n    "args": user_lock_hash | version | sudtMin |ckbMin |info_type_hash_32 |tips |   \n            tips_sudt  ( "|" refers to bytes concatenation),\n    "hash_type": -,\n  },\n}\n')),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Field description :")," (total size: 235 bytes)"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"capacity"),"(size: 8 bytes)"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"data"),"(size: 16 bytes):  When selling sudt, ",Object(l.b)("inlineCode",{parentName:"li"},"data")," should be ",Object(l.b)("inlineCode",{parentName:"li"},"sudt_amount")," . When buying sudt, ",Object(l.b)("inlineCode",{parentName:"li"},"data")," should be null."),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"type script")," (size: 65 bytes):  When selling sudt, ",Object(l.b)("inlineCode",{parentName:"li"},"type script")," should be ",Object(l.b)("inlineCode",{parentName:"li"},"sudt_type")," . When buying sudt, ",Object(l.b)("inlineCode",{parentName:"li"},"type script")," should be  null. "),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"lock script")," (size: 146 bytes) ",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"code_hash")," (size: 32 bytes): ",Object(l.b)("inlineCode",{parentName:"li"},"SWAP_REQ_LOCK_CODE_HASH")," "),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"args"),":",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"user_lock_hash")," (size: 32 bytes)"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"version")," (type: uint 8, size: 1 byte)"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"amountOutMin")," (type: uint 128, size: 16 bytes):  ",Object(l.b)("inlineCode",{parentName:"li"},"amountOutMin"),"  represents the minimum amount of tokens that trader can redeem. For example, when using sUDT to exchange for CKB, the ",Object(l.b)("inlineCode",{parentName:"li"},"amountOutMin"),"  should be the minimum amount of the redeemed CKB, not the minimum capacity of all cell."),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"tips")," (size: 8 bytes):  The amount of CKB that user pay to miner and aggregator."),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"tips_sudt"),"(size: 16 bytes): The amount of sUDT that user pay to  aggregator."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"hash_type")," (size: 1 byte)")))),Object(l.b)("h2",{id:"liquidity-request-cell"},"Liquidity Request Cell"),Object(l.b)("p",null,"Liquidity request cell is used for add liquidity to liquidity pool or remove liquidity from liquidity pool by liquidity provider."),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{}),'{\n  "capacity": -,\n  "data": sudt_amount,\n  "type": asset_sudt_type or liquidity_sudt_type,\n  "lock": {\n    "code_hash": LIQUIDITY_REQ_LOCK_CODE_HASH,\n    "args": user_lock_hash | version | sudtMin |ckbMin |info_type_hash_32 |tips |   \n            tips_sudt  ( "|" refers to bytes concatenation),\n    "hash_type": -,\n  },\n  \n}\n')),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Field description :")," (total size: 235 bytes)"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"capacity"),"(size: 16 bytes)"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"data"),"(size: 16 bytes, byte order: little endian) "),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"type script"),"(size: 65 bytes):  When adding liquidity, the type script is ",Object(l.b)("inlineCode",{parentName:"li"},"asset_sudt_type"),". When removing liquidity, the type script is ",Object(l.b)("inlineCode",{parentName:"li"},"liquidity_sudt_type"),".  "),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"lock script"),"(size: 146 bytes)",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"code_hash")," (size: 32 bytes): ",Object(l.b)("inlineCode",{parentName:"li"},"LIQUIDITY_REQ_LOCK_CODE_HASH")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"args"),": ",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"user_lock_hash")," (size: 32  bytes)"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"version")," (type: uint 8, size: 1 byte)"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"sudtMin")," (type: uint 128, size: 16 bytes,  byte order: little endian) : When it is initial liquidity, ",Object(l.b)("inlineCode",{parentName:"li"},"sudtMin")," has no meaning. When adding liquidity, ",Object(l.b)("inlineCode",{parentName:"li"},"sudtMin"),"  represents the minimum amount of CKB that could be used to add liquidity. While removing liquidity, ",Object(l.b)("inlineCode",{parentName:"li"},"sudtMin")," represents the minimum amount of sUDT that could be removed when Liquidity token runs out."),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"ckbMin")," (type: uint 64, size: 8 bytes, byte order: little endian):  When it is initial liquidity,  ",Object(l.b)("inlineCode",{parentName:"li"},"ckbMin"),"  has no meaning. When adding liquidity, ",Object(l.b)("inlineCode",{parentName:"li"},"ckbMin"),"  means minimum amount of CKB that could be used to add liquidity. While removing liquidity, ",Object(l.b)("inlineCode",{parentName:"li"},"ckbMin")," means minimum amount of CKB  that could be removed when Liquidity token runs out."),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"info_type_hash_32")," (size: 32 bytes)"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"tips"),"(size: 8 bytes):  The amount of CKB that user pay to miner and aggregator."),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"tips_sudt"),"(size: 16 bytes): The amount of sUDT that user pay to  aggregator."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"hash_type")," (size: 1 byte)")))),Object(l.b)("h2",{id:"info-cell"},"Info Cell"),Object(l.b)("p",null,"Info cell represents the current state of liquidity pool."),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{}),'{\n  "capacity": -,\n  "data": {\n     "ckb_reserve": ,\n     "sudt_reserve": ,\n     "total_liquidity": ,\n     "liquidity_sudt_type_hash": ,\n    },\n  "type": {\n    "code_hash": INFO_TYPE_CODE_HASH, \n    "args": id,\n    "hash_type": ,\n  },\n  "lock": {\n    "code_hash": INFO_LOCK_CODE_HASH,\n    "args": hash(ckb | asset_sudt_type_hash) | info_type_hash  ( "|" refers to bytes concatenation),\n    "hash_type": -,\n  },\n}\n')),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Field description :"),"\uff08total size: 250 bytes) "),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"capacity"),"(size: 8 bytes)"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"data")," (size : 80 bytes)",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"ckb_reserve"),"(type: u128, size: 16 bytes) \uff1aTotal remaining amount of CKB  in the liquidity pool. "),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"sudt_reserve"),"(type: u128, size: 16 bytes):  Total remaining amount of sUDT in the liquidity pool. "),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"total_liquidity")," (type: u128, size: 16 bytes): Total liquidity token issued. "),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"liquidity_sudt_type_hash")," (size: 32 bytes):  Liquidty token type hash of this pool. "))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"type script"),"(size: 65 bytes\uff09",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"code_hash")," (size: 32 bytes): ",Object(l.b)("inlineCode",{parentName:"li"},"INFO_TYPE_CODE_HASH")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"args"),"(size: 32 bytes):   ",Object(l.b)("inlineCode",{parentName:"li"},"id"),"  =  ",Object(l.b)("inlineCode",{parentName:"li"},"TypeId ")," which is the input index","[1]"," outpoint ."),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"hash_type")," (size: 1 byte)"))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"lock script")," (size: 97 bytes\uff09",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"code_hash")," (size: 32 bytes):  ",Object(l.b)("inlineCode",{parentName:"li"},"INFO_LOCK_CODE_HASH")," "),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"args"),"(size: 32 bytes):",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"hash(ckb | asset_sudt_type_hash)"),"(size: 32 bytes): The order of CKB and sUDT in here follows dictionary order"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"info_type_hash")," (size: 32 bytes): The unlock rule relies on info type script."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"hash_type")," (size: 1 byte)")))),Object(l.b)("h2",{id:"pool-cell"},"Pool Cell"),Object(l.b)("p",null,"Pool cell is used for fund custody."),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{}),'{\n  "capacity": -,\n  "data": sudt_amount,\n  "type": sudt_type,\n  "lock": info_lock,\n}\n')),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Field description :")," \uff08total size: 186 bytes) "),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("p",{parentName:"li"},Object(l.b)("inlineCode",{parentName:"p"},"capacity"),"  (size: 8 bytes)")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("p",{parentName:"li"},Object(l.b)("inlineCode",{parentName:"p"},"data"),"(size: 16 bytes) : The amount of sUDT in liquidity pool.")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("p",{parentName:"li"},Object(l.b)("inlineCode",{parentName:"p"},"type script")," (size: 65 bytes) : sUDT type.")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("p",{parentName:"li"},Object(l.b)("inlineCode",{parentName:"p"},"lock script")," (size: 97 bytes): Same with info cell lock. "))),Object(l.b)("h2",{id:"liquidty-token-cell"},"Liquidty Token Cell"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{}),'{\n  "capacity": -,\n  "data": amount,\n  "type": {\n    "code_hash": sudt_type_script,\n    "args": info_cell_lock_hash,\n  },\n  "lock": user_lock,\n}\n')),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Field description :")," \uff08total size: 154 bytes) "),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"capacity"),"  (size: 8 bytes)"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"data"),"(type: uint 128, size: 16 bytes)"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"type script")," (size: 65 bytes)",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"code_hash"),": ",Object(l.b)("inlineCode",{parentName:"li"},"sudt_type_script")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"args"),":  in here, we use info cell lock hash as ",Object(l.b)("inlineCode",{parentName:"li"},"owner_lock_hash"),", since each time the liquidity tokens are minted or burned, info cell are required to be existed in this tx.input"))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"lock script "),"(size: 65 bytes) : ",Object(l.b)("inlineCode",{parentName:"li"},"user_lock"))))}s.isMDXComponent=!0}}]);