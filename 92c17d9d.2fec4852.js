(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{117:function(t,e,n){"use strict";n.d(e,"a",(function(){return d})),n.d(e,"b",(function(){return p}));var i=n(0),r=n.n(i);function o(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function a(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(t);e&&(i=i.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,i)}return n}function l(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?a(Object(n),!0).forEach((function(e){o(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function u(t,e){if(null==t)return{};var n,i,r=function(t,e){if(null==t)return{};var n,i,r={},o=Object.keys(t);for(i=0;i<o.length;i++)n=o[i],e.indexOf(n)>=0||(r[n]=t[n]);return r}(t,e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);for(i=0;i<o.length;i++)n=o[i],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(r[n]=t[n])}return r}var c=r.a.createContext({}),s=function(t){var e=r.a.useContext(c),n=e;return t&&(n="function"==typeof t?t(e):l(l({},e),t)),n},d=function(t){var e=s(t.components);return r.a.createElement(c.Provider,{value:e},t.children)},_={inlineCode:"code",wrapper:function(t){var e=t.children;return r.a.createElement(r.a.Fragment,{},e)}},f=r.a.forwardRef((function(t,e){var n=t.components,i=t.mdxType,o=t.originalType,a=t.parentName,c=u(t,["components","mdxType","originalType","parentName"]),d=s(n),f=i,p=d["".concat(a,".").concat(f)]||d[f]||_[f]||o;return n?r.a.createElement(p,l(l({ref:e},c),{},{components:n})):r.a.createElement(p,l({ref:e},c))}));function p(t,e){var n=arguments,i=e&&e.mdxType;if("string"==typeof t||i){var o=n.length,a=new Array(o);a[0]=f;var l={};for(var u in e)hasOwnProperty.call(e,u)&&(l[u]=e[u]);l.originalType=t,l.mdxType="string"==typeof t?t:i,a[1]=l;for(var c=2;c<o;c++)a[c]=n[c];return r.a.createElement.apply(null,a)}return r.a.createElement.apply(null,n)}f.displayName="MDXCreateElement"},94:function(t,e,n){"use strict";n.r(e),n.d(e,"frontMatter",(function(){return a})),n.d(e,"metadata",(function(){return l})),n.d(e,"toc",(function(){return u})),n.d(e,"default",(function(){return s}));var i=n(3),r=n(7),o=(n(0),n(117)),a={id:"info-type-script",title:"Info Cell Type Script"},l={unversionedId:"tx-script/info-type-script",id:"tx-script/info-type-script",isDocsHomePage:!1,title:"Info Cell Type Script",description:"1. Rule 1 - TypeID rules",source:"@site/docs/tx-script/info-type-script.md",slug:"/tx-script/info-type-script",permalink:"/gliaswap-docs/docs/tx-script/info-type-script",editUrl:"https://github.com/facebook/docusaurus/edit/master/website/docs/tx-script/info-type-script.md",version:"current",sidebar:"docs",previous:{title:"Pool transaction structure",permalink:"/gliaswap-docs/docs/tx-script/pool-tx"},next:{title:"Info Cell Lock Script",permalink:"/gliaswap-docs/docs/tx-script/info-lock-script"}},u=[],c={toc:u};function s(t){var e=t.components,n=Object(r.a)(t,["components"]);return Object(o.b)("wrapper",Object(i.a)({},c,n,{components:e,mdxType:"MDXLayout"}),Object(o.b)("h4",{id:"1-rule-1---typeid-rules"},"1. Rule 1 - ",Object(o.b)("a",Object(i.a)({parentName:"h4"},{href:"https://github.com/nervosnetwork/ckb/blob/master/script/src/type_id.rs"}),"TypeID rules")),Object(o.b)("h4",{id:"2-rule-2---if-this-is-a-matching-swap-transaction-the-cell-sequence-in-this-tx-should-follow-the-rules-blow"},"2. Rule 2 - If this is a matching swap transaction, the cell sequence in this tx should follow the rules blow:"),Object(o.b)("pre",null,Object(o.b)("code",Object(i.a)({parentName:"pre"},{className:"language-text"}),"\ninfo_in_cell                            info_out_cell\npool_in_cell                            pool_out_cell\n                          -------\x3e\nmatcher_in_cell                         matcher_out_cell\n[swap_request_cell]                     [sudt_cell or ckb_cell]\n\n")),Object(o.b)("h4",{id:"3-rule-3---if-this-is-a-swap-matching-transaction-verify-whether-the-data-changes-in-the-info-cell-is-correct-and-corresponding-to-the-actual-increase-or-decrease-in-the-amount-of-assets-in-the-pool-cell"},"3. Rule 3 - If this is a swap matching transaction, verify whether the data changes in the info cell is correct and corresponding to the actual increase or decrease in the amount of assets in the pool cell"),Object(o.b)("p",null,"Notice\uff1aIn pseudo code blow\uff0ctotal_liqidity is the Liquidity token balance in info cell, and liquidity_sudt_type_hash is Liquidity token type hash."),Object(o.b)("pre",null,Object(o.b)("code",Object(i.a)({parentName:"pre"},{}),"let info_in = inputs[0]\nlet pool_in = inputs[1]\nlet info_out = outputs[0]\nlet pool_out = outputs[1]\n\nif info_out.capacity != INFO_CAPACITY\n    || info_out.data.total_liquidity != info_in.data.total_liquidity\n    return fail\n\nlet ckb_got = BigInt::from(info_out.data.ckb_reserve) - info_in.data.ckb_reserve\nlet sudt_got = BigInt::from(info_out.data.sudt_reserve) - info_in.data.sudt_reserve\n\nlet ckb_reserve = info_in.data.ckb_reserve\nlet sudt_reserve = info_in.data.sudt_reserve\n\nif ckb_got > 0 && sudt_got < 0 // tx buy sudt\n    let sudt_paid = info_in.data.sudt_reserve - info_out.data.sudt_reserve\n\n    if ckb_got != (1000 * ckb_reserve * sudt_paid) / (997 * (sudt_reserve - sudt_paid))\n        return fail\nelse if ckb_got < 0 && sudt_got > 0 // tx sell sudt\n    let ckb_paid = info_in.data.ckb_reserve - info_out.data.ckb_reserve\n\n    if sudt_got != (1000 * sudt_reserve * ckb_paid) / (997 * (ckb_reserve - ckb_paid))\n        return fail\nelse\n    return fail\nfi\n\nif pool_out.capacity != pool_in.capacity + ckb_got\n    || pool_out.data.amount != pool_in.data.amount + sudt_got\n    return fail\n\nreturn success\n")),Object(o.b)("h4",{id:"4-rule-4----if-this-is-a-creating-pool-transaction-verify-that-the-pool-cell-is-created-at-the-same-time-as-the-info-cell-and-that-the-data-filled-in-info-cell-and-pool-cell-are-correct"},"4. Rule 4  - If this is a creating pool transaction, verify that the Pool cell is created at the same time as the Info cell, and that the data filled in info cell and pool cell are correct."),Object(o.b)("pre",null,Object(o.b)("code",Object(i.a)({parentName:"pre"},{}),"if none_of(input.type.code_hash) == INFO_TYPE_CODE_HASH // Info creation\n    info_id_verification()\n\n    if count(output.lock.code_hash == INFO_LOCK_CODE_HASH) != 2 // pool not found\n        || info.lock.hash_type != 1\n        || info.lock.args[0..32] != hash(ckb | pool.type_hash\n        || info.lock.args[32..64] != info.type_hash\n        || info.lock_hash != pool.lock_hash\n        || pool.data.size < 16\n        return fail\n")),Object(o.b)("h4",{id:"5-rule-5---if-this-is-a-matching-liquidity-transaction-the-cell-sequence-in-this-tx-should-follow-the-rules-blow"},"5. Rule 5 - If this is a matching liquidity transaction, the cell sequence in this tx should follow the rules blow:"),Object(o.b)("pre",null,Object(o.b)("code",Object(i.a)({parentName:"pre"},{className:"language-text"}),"\ninfo_in_cell                            info_out_cell\npool_in_cell                            pool_out_cell\n                          -------\x3e\naggregator_in_cell                      aggregator_out_cell\n[remove_liquidity_request_cell]         [sudt_cell]\n[add_liquidity_request_cell]            [liquidity_cell + change_cell(sudt_cell or ckb_cell)]\n\n")),Object(o.b)("h4",{id:"6-rules-6---if-this-is-initially-adding-liquidity-verify-if-minting-the-correct-amount-liquidity-token-for-user-and-verify-if-the-data-storaged-in-info-cell-and-pool-cell-is-correct"},"6. Rules 6 - If this is initially adding liquidity, verify if minting the correct amount Liquidity token for user, and verify if the data storaged in info cell and pool cell is correct."),Object(o.b)("p",null,"Notice\uff1aIn pseudo code blow\uff0ctotal_liqidity is the Liquidity token balance in info cell, and liquidity_sudt_type_hash is Liquidity token type hash."),Object(o.b)("pre",null,Object(o.b)("code",Object(i.a)({parentName:"pre"},{}),"let info_in = inputs[0]\nlet pool_in = inputs[1]\nlet matcher_in = inputs[2]\nlet info_out = outputs[0]\nlet pool_out = outputs[1]\nlet matcher_out = outputs[2]\n\nlet ckb_reserve = info_in.data.ckb_reserve\nlet sudt_reserve = info_in.data.sudt_reserve\nlet total_liquidity = info_in.data.total_liquidity\n\nlet pool_ckb_paid = 0\nlet pool_sudt_paid = 0\nlet ckb_collected = 0\nlet sudt_collected = 0\nlet user_liquidity_added = 0\nlet user_liquidity_removed = 0\n\nfn verify_genesis_add_liquidity()\n    if ckb_reserve != 0\n        || sudt_reserve != 0\n        || total_liquidity != 0\n        return fail\n\n    let liquidity = outputs[req_index_in_inputs]\n    let user_lock_hash = req.lock.args[0..32]\n    if liquidity.type_hash != info.data.liquidity_sudt_type_hash\n        || liquidity.lock_hash != user_lock_hash\n        reutrn fail\n\n    let sudt_injected = BigUint::from(req.data.amount)\n    let ckb_injected = BigUint::from(req.capacity - SUDT_CAPACITY)\n\n    let user_liquidity = BigUint::from(liquidity.data.amount)\n    let added_liquidity: u128 = (sudt_injected * ckb_injected).sqrt().try_into().unwrap();\n    if user_liquidity != added_liquidity\n        return fail\n\n    ckb_collected += ckb_injected\n    sudt_collected += req.data.amount\n    user_liquidity_added += user_liquidity\nendfn\n")),Object(o.b)("h4",{id:"7-rule-7---if-this-is-not-initially-adding-liquidity-iterate-through-all-request-cell"},"7. Rule 7 - If this is not initially adding liquidity, iterate through all request cell"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"If it is add liquidity request cell, verify if minting the correct amount Liquidity token for user, and add up the CKB amount, sUDT amount and Liquidity token amount for verifying info cell and pool cell later."),Object(o.b)("li",{parentName:"ul"},"If it is remove liquidity request cell, verify if withdraw the correct CKB amount and sudt amount for user, and add up the CKB amount, sUDT amount and Liquidity token amount for verifying info cell and pool cell later."),Object(o.b)("li",{parentName:"ul"},"Verify if the data storaged in info cell and pool cell is correct ")),Object(o.b)("pre",null,Object(o.b)("code",Object(i.a)({parentName:"pre"},{}),"fn verify_add_liquidity()\n    if total_liquidity == 0\n        return fail\n\n    let liquidity = outputs[req_index_in_inputs * 2]\n    let change = outputs[req_index_in_inputs * 2 + 1]\n\n    let user_lock_hash = req.lock.args[0..32]\n    if liquidity.type_hash != info.data.liquidity_sudt_type_hash\n        || liquidity.lock_hash != user_lock_hash\n       Outdated doc. reutrn fail\n\n    let user_liquidity = BigUint::from(liquidity.data.amount)\n\n    // Check sudt exhaustion\n    if change.data.size == 0\n      if !change.type.is_none()\n          || change.lock_hash != user_lock_hash\n          return fail\n\n      let sudt_injected = BigUint::from(req.data.amount)\n      let ckb_injected = BigUint::from(req.capacity - SUDT_CAPACITY - change.capacity) // SUDT_CAPACITY for liquidity cell\n\n      if ckb_injected != (sudt_injected * ckb_reserve / sudt_injected) + 1\n          return fail\n\n      // Check ckb_injected > min_ckb_injected\n      let min_ckb_injected = BigUint::from(req.lock.args[49..57])\n      if min_ckb_injected == 0\n          || ckb_injected < min_ckb_injected\n          return fail\n\n      if user_liquidity != sudt_injected * total_liquidity / sudt_reserve\n          return fail\n\n    // Check ckb exhaustion\n    else if change.data.size >= 16\n      if change.type_hash != pool.type_hash\n          || change.lock_hash != user_lock_hash\n          return fail\n\n      let sudt_injected = BigUint::from(req.data.amount - change.data.amount)\n      let ckb_injected = BigUint::from(req.capacity - SUDT_CAPACITY * 2) // Two SUDT_CAPACITY for liquidity cell and sudt change cell\n\n      if sudt_injected != (ckb_injected * sudt_reserve / ckb_reserve) + 1\n          return fail\n\n      // Check sudt_injected > min_sudt_injected\n      let min_sudt_injected = BigUint::from(req.lock.args[33..49])\n      if min_sudt_injected == 0\n          || sudt_injected < min_sudt_injected\n          return fail\n\n      if user_liquidity != ckb_injected * total_liquidity / ckb_reserve\n          return fail\n\n    else\n        return fail\n    fi\n\n    ckb_collected += ckb_injected\n    sudt_collected += sudt_injected\n    user_liquidity_added += user_liquidity\nendfn\n\nfn verify_remove_liquidity()\n    if total_liquidity == 0\n        return fail\n\n    if req.data.amount == 0\n        return fail\n\n    let output_a = outputs[req_index_in_inputs];\n    let output_b = outputs[req_index_in_inputs + 1];\n    if output_a.type.is_none() && output_b.type.is_some()\n        let ckb_out = output_a;\n        let sudt_out = output_b;\n    else if output_a.type.is_some() && output_b.type.is_none()\n        let ckb_out = output_b;\n        let sudt_out = output_a;\n    else\n        return fail\n    fi\n\n    if sudt_out.capacity != SUDT_CAPACITY\n        return fail\n\n    if ckb_out.data.size != 0\n        || sudt_out.data.size < 16\n        return fail\n\n    let user_lock_hash = req.lock.args[0..32]\n    if sudt_out.type_hash != pool.type_hash\n        || sudt_out.lock_hash != user_lock_hash\n        || ckb_out.lock_hash != user_lock_hash\n        return fail\n\n    let user_ckb_got = BigUint::from(ckb_out.capacity - req.capacity)\n    let user_sudt_got = BigUint::from(sudt_out.data.amount)\n    let removed_liquidity = BigUint::from(req.data.amount)\n\n    // Check user_ckb_got >= min_ckb_got\n    let min_ckb_got = req.lock.args[49..57]\n    if min_ckb_got == 0\n        || user_ckb_got < min_ckb_got\n        return fail\n\n    // Check user_sudt_got >= min_sudt_got\n    let min_sudt_got = req.lock.args[33..49]\n    if min_sudt_got == 0\n        || user_sudt_got < min_sudt_got\n        return fail\n\n    if user_ckb_got != removed_liquidity * ckb_reserve / total_liquidity\n        return fail\n\n    if user_sudt_got != removed_liquidity * sudt_reserve / total_liquidity\n        return fail\n\n    pool_ckb_paid += user_ckb_got\n    pool_sudt_paid += user_sudt_got\n    user_liquidity_removed += removed_liquidity\n\n    assert(pool_ckb_paid < ckb_reserve)\n    assert(pool_sudt_paid < sudt_reserve)\n    assert(user_liquidity_removed < total_liquidity)\nendfn\n\nfor req in inputs[3..]\n    let version = req.lock.args[32..33]\n    if INFO_req_VERSION != version\n        return fail\n\n    let req_info_type_hash = req.lock.args[57..89]\n    if req.data.size < 16\n        || req_info_type_hash != info.type_hash\n        return fail\n\n    if info.data.total_liquidity == 0\n        // Only allow on req to provide genesis liquidity\n        if count(inputs) - 3 != 1\n          return fail\n\n        verify_genesis_add_liquidity()\n        break\n\n    match req.type_hash\n        info.data.liquidity_sudt_type_hash => verify_remove_liquidity(req)\n        pool.type_hash => verify_add_liquidity(req)\n        _ => return fail // unknown liquidity req\nendfor\n\nif info_out.capacity != INFO_CAPACITY\n    || info_out.data.ckb_reserve != info_in.data.ckb_reserve - pool_ckb_paid + ckb_collected\n    || info_out.data.sudt_reserve != info_in.data.sudt_reserve - pool_sudt_paid + token_collected\n    || BigUint::from(info_out.data.total_liquidity) !=\n        BigUint::from(info_in.data.total_liquidity) - user_liquidity_removed +  user_liquidity_added\n    return fail\n\nif pool_out.capacity != pool_in.capacity + info_out.data.ckb_reserve - info_in.data.ckb_reserve\n    || pool_out.data.amount != info_out.data.sudt_reserve\n    return fail\n\nreturn success\n")))}s.isMDXComponent=!0}}]);