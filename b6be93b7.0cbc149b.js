(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{102:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return r})),n.d(t,"metadata",(function(){return o})),n.d(t,"toc",(function(){return b})),n.d(t,"default",(function(){return s}));var i=n(3),l=n(7),a=(n(0),n(117)),r={id:"cell",title:"Cell Structure"},o={unversionedId:"tx-script/cell",id:"tx-script/cell",isDocsHomePage:!1,title:"Cell Structure",description:"Gliaswap support swap and pool by specifying several cell formats and implementing a set of scripts.",source:"@site/docs/tx-script/cell.md",slug:"/tx-script/cell",permalink:"/gliaswap-docs/docs/tx-script/cell",editUrl:"https://github.com/facebook/docusaurus/edit/master/website/docs/tx-script/cell.md",version:"current",sidebar:"docs",previous:{title:"Fee Structure",permalink:"/gliaswap-docs/docs/product/fee"},next:{title:"Swap Transaction Structure",permalink:"/gliaswap-docs/docs/tx-script/swap-tx"}},b=[{value:"Swap Request Cell",id:"swap-request-cell",children:[]},{value:"Liquidity Request Cell",id:"liquidity-request-cell",children:[]},{value:"Info Cell",id:"info-cell",children:[]},{value:"Pool Cell",id:"pool-cell",children:[]},{value:"Liquidty Token Cell",id:"liquidty-token-cell",children:[]}],c={toc:b};function s(e){var t=e.components,n=Object(l.a)(e,["components"]);return Object(a.b)("wrapper",Object(i.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("p",null,"Gliaswap support swap and pool by specifying several cell formats and implementing a set of scripts."),Object(a.b)("p",null,"In Gliaswap, traders and LPs all need to submit requests firstly, and then the aggregator can help them to complete the swap or manage liquidity."),Object(a.b)("p",null,"A request in Gliaswap is a live cell on the chain which also can be thought of as a data package that signals what you want to do. And a request cell is identified and constrained by its lock. There are two types of request cell:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("p",{parentName:"li"},Object(a.b)("strong",{parentName:"p"},"Swap Request Cell"),": when swapping between CKB and sUDT, LPs need to make a request firstly by creating a swap request cell. This request cell signals what you want to trade, for what token, and how much you want. More details can refer to the following swap request cell format part. ")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("p",{parentName:"li"},Object(a.b)("strong",{parentName:"p"},"Liquidity Request Cell"),": when adding liquidity or removing liquidity from the pool, LPs need to make a request first by creating a liquidity request cell. This request cell signals what token pair you want to supply, for which pool, how much you want to supply. More details can refer to the following liquidity request cell format part. "))),Object(a.b)("p",null,"A pool of one token pair in Gliaswap is two cells on the chain - info cell and pool cell. "),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"The ",Object(a.b)("strong",{parentName:"li"},"info cell")," is used to store the global states of this pool and restrict the rules for changing the status information. "),Object(a.b)("li",{parentName:"ul"},"The ",Object(a.b)("strong",{parentName:"li"},"pool cell")," is used to store the real tokens. "),Object(a.b)("li",{parentName:"ul"},"These two cells have the same lock script and different type script, and more details can refer to the following info cell and pool cell format part. ")),Object(a.b)("p",null,"Liquidity tokens are minted to track the relative proportion of total reserves that each liquidity provider has contributed. In Gliaswap, liquidity token followed sUDT standard and use info lock as its owner lock. More details can refer to the following ",Object(a.b)("strong",{parentName:"p"},"liquidity token cell")," format part. "),Object(a.b)("h2",{id:"swap-request-cell"},"Swap Request Cell"),Object(a.b)("p",null,"The swap request cell is used for selling or buying assets."),Object(a.b)("p",null,"when using sUDT to buy CKB:"),Object(a.b)("pre",null,Object(a.b)("code",Object(i.a)({parentName:"pre"},{}),"SWAP_REQ_CAPACITY_SELL - 227 bytes\n{\n  capacity: - 8 bytes\n  data: - 16 bytes for sell\n      sudt_amount: u128\n  type: sudt_type for sell - 65 bytes\n  lock: - 138 bytes\n      code: SWAP_REQ_LOCK_CODE_HASH - 32 bytes + 1 byte\n      args: sudt_type_hash (32 bytes, 0..32) | \n          version (u8, 1 byte, 32..33) | \n          amountOutMin (u128, 16 bytes, 33..49) | \n          user_lock_hash (32 bytes, 49..81) | \n          tips (8 bytes, 81..89) | \n          tips_sudt (16 bytes, 89..105)\n}\n")),Object(a.b)("p",null,"when using CKB to buy sUDT:"),Object(a.b)("pre",null,Object(a.b)("code",Object(i.a)({parentName:"pre"},{}),"SWAP_REQ_CAPACITY_SELL - 146 bytes\n{\n  capacity: - 8 bytes\n  data: null for buy - 0 bytes\n  type: null for buy - 0 bytes\n  lock: - 138 bytes\n      code: SWAP_REQ_LOCK_CODE_HASH - 32 bytes + 1 byte\n      args: sudt_type_hash (32 bytes, 0..32) | \n                version (u8, 1 byte, 32..33) | \n                amountOutMin (u128, 16 bytes, 33..49) | \n                user_lock_hash (32 bytes, 49..81) | \n                tips (8 bytes, 81..89) | \n                tips_sudt (16 bytes, 89..105)\n}\n")),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"Field description :")," "),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"capacity")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"data"),": When selling sudt, ",Object(a.b)("inlineCode",{parentName:"li"},"data")," should be ",Object(a.b)("inlineCode",{parentName:"li"},"sudt_amount")," . When buying sudt, ",Object(a.b)("inlineCode",{parentName:"li"},"data")," should be null."),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"type script"),": When selling sudt, ",Object(a.b)("inlineCode",{parentName:"li"},"type script")," should be ",Object(a.b)("inlineCode",{parentName:"li"},"sudt_type")," . When buying sudt, ",Object(a.b)("inlineCode",{parentName:"li"},"type script")," should be  null. "),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"lock script")," ",Object(a.b)("ul",{parentName:"li"},Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"code_hash"),": ",Object(a.b)("inlineCode",{parentName:"li"},"SWAP_REQ_LOCK_CODE_HASH")," "),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"args"),":",Object(a.b)("ul",{parentName:"li"},Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"version")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"amountOutMin"),": ",Object(a.b)("inlineCode",{parentName:"li"},"amountOutMin"),"  represents the minimum amount of tokens that trader can redeem. For example, when using sUDT to exchange for CKB, the ",Object(a.b)("inlineCode",{parentName:"li"},"amountOutMin")," should be the minimum amount of the redeemed CKB, not the minimum capacity of all cell."),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"user_lock_hash"),": hash of user's lock"),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"tips"),": The amount of CKB that user pay to miner and aggregator."),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"tips_sudt"),": The amount of sUDT that user pay to  aggregator."))),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"hash_type")," ")))),Object(a.b)("h2",{id:"liquidity-request-cell"},"Liquidity Request Cell"),Object(a.b)("p",null,"Liquidity request cell is used for add liquidity to liquidity pool or remove liquidity from liquidity pool by liquidity provider."),Object(a.b)("pre",null,Object(a.b)("code",Object(i.a)({parentName:"pre"},{}),"cell size: 235 bytes\n{\ncapacity: - 8 bytes\ndata: - 16 bytes\n    sudt_amount: u128\ntype: asset_sudt_type for add / liquidity_sudt_type for remove - 65 bytes\nlock: - 146 bytes\n    code: LIQUIDITY_REQ_LOCK_CODE_HASH - 32 bytes + 1 byte\n    args: info_type_hash_32 (32 bytes, 0..32) | \n              version (u8, 1 byte, 32..33) | \n              sudtMin (u128, 16 bytes, 33..49) | \n              ckbMin (u64, 8 bytes, 49..57) | \n              user_lock_hash (32 bytes, 57..89) | \n              tips (8 bytes, 89..97) | \n              tips_sudt (16 bytes, 97..113) \n}\n")),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"Field description :")," (total size: 235 bytes)"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"lock script"),Object(a.b)("ul",{parentName:"li"},Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"code_hash")," : ",Object(a.b)("inlineCode",{parentName:"li"},"LIQUIDITY_REQ_LOCK_CODE_HASH")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"args"),": ",Object(a.b)("ul",{parentName:"li"},Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"sudtMin")," (byte order: little endian) : When it is initially adding liquidity, ",Object(a.b)("inlineCode",{parentName:"li"},"sudtMin")," has no meaning. When it is not initially adding liquidity, ",Object(a.b)("inlineCode",{parentName:"li"},"sudtMin"),"  represents the minimum amount of CKB that could be used to add liquidity. While removing liquidity, ",Object(a.b)("inlineCode",{parentName:"li"},"sudtMin")," represents the minimum amount of sUDT that users will receive."),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"ckbMin")," (byte order: little endian):  When it is initially adding liquidity,  ",Object(a.b)("inlineCode",{parentName:"li"},"ckbMin"),"  has no meaning. When it is not initially adding liquidity, ",Object(a.b)("inlineCode",{parentName:"li"},"ckbMin"),"  means minimum amount of CKB that could be used to add liquidity. While removing liquidity, ",Object(a.b)("inlineCode",{parentName:"li"},"ckbMin")," means minimum amount of CKB  that users will receive."),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"info_type_hash_32"),": type hash of info cell"),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"tips"),":  The amount of CKB that users pay to the aggregator."),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"tips_sudt"),": The amount of sUDT that user pay to  aggregator.")))))),Object(a.b)("h2",{id:"info-cell"},"Info Cell"),Object(a.b)("p",null,"Info cell represents the current state of liquidity pool."),Object(a.b)("pre",null,Object(a.b)("code",Object(i.a)({parentName:"pre"},{}),"cell size: 250 bytes\n{\ncapacity: - 8 bytes\ndata: - 80 bytes\n    ckb_reserve: u128 16 bytes\n    sudt_reserve: u128\n    total_liquidity: u128\n    liquidity_sudt_type_hash: 32 bytes\ntype: - 65 bytes\n    code: INFO_TYPE_CODE_HASH - 32 bytes + 1 byte\n    args: id - 32 bytes\nlock: - 97 bytes\n    code: INFO_LOCK_CODE_HASH - 32 bytes + 1 byte\n    args: hash(ckb | asset_sudt_type_hash) 32 bytes | info_type_hash - 32 bytes \n}\n")),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"Field description :")),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"data")," ",Object(a.b)("ul",{parentName:"li"},Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"ckb_reserve"),"\uff1aTotal remaining amount of CKB  in the liquidity pool. "),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"sudt_reserve"),":  Total remaining amount of sUDT in the liquidity pool. "),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"total_liquidity"),": Total liquidity token issued. "),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"liquidity_sudt_type_hash"),":  Liquidty token type hash of this pool. "))),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"type script"),Object(a.b)("ul",{parentName:"li"},Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"args"),":   ",Object(a.b)("inlineCode",{parentName:"li"},"id"),"  =  ",Object(a.b)("inlineCode",{parentName:"li"},"TypeId ")," which is the input index","[1]"," outpoint ."))),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"lock script")," (size: 97 bytes\uff09",Object(a.b)("ul",{parentName:"li"},Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"args"),":",Object(a.b)("ul",{parentName:"li"},Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"hash(ckb | asset_sudt_type_hash)"),": The order of CKB and sUDT in here follows dictionary order"),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"info_type_hash")," : The unlock rule relies on info type script.")))))),Object(a.b)("h2",{id:"pool-cell"},"Pool Cell"),Object(a.b)("p",null,"Pool cell is used for fund custody."),Object(a.b)("pre",null,Object(a.b)("code",Object(i.a)({parentName:"pre"},{}),"cell size - 186 bytes\n{\ncapacity: - 8 bytes\ndata: - 16 bytes\n    sudt_amount\ntype: sudt_type - 65 bytes\nlock: info_lock - 97 bytes\n}\n")),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"Field description :")," "),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("p",{parentName:"li"},Object(a.b)("inlineCode",{parentName:"p"},"capacity"),": The amount of CKB in liquidity pool.")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("p",{parentName:"li"},Object(a.b)("inlineCode",{parentName:"p"},"data"),": The amount of sUDT in liquidity pool.")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("p",{parentName:"li"},Object(a.b)("inlineCode",{parentName:"p"},"type script"),": sUDT type.")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("p",{parentName:"li"},Object(a.b)("inlineCode",{parentName:"p"},"lock script"),": Same with info cell lock. "))),Object(a.b)("h2",{id:"liquidty-token-cell"},"Liquidty Token Cell"),Object(a.b)("pre",null,Object(a.b)("code",Object(i.a)({parentName:"pre"},{}),"cell size - 142 bytes\n{\ncapacity: - 8 bytes\ndata: amount: u128 - 16 bytes\ntype: - 65 bytes\n    code: sudt_type_script\n    args: info_cell_lock_hash\nlock: user_lock - 53 bytes\n}\n")),Object(a.b)("p",null,Object(a.b)("strong",{parentName:"p"},"Field description :")," "),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"type script")," (size: 65 bytes)",Object(a.b)("ul",{parentName:"li"},Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"code_hash"),": ",Object(a.b)("inlineCode",{parentName:"li"},"sudt_type_script")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("inlineCode",{parentName:"li"},"args"),":  in here, we use info cell lock hash as ",Object(a.b)("inlineCode",{parentName:"li"},"owner_lock_hash"),", since each time the liquidity tokens are minted or burned, info cell are required to be existed in this tx.input")))))}s.isMDXComponent=!0},117:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return m}));var i=n(0),l=n.n(i);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function b(e,t){if(null==e)return{};var n,i,l=function(e,t){if(null==e)return{};var n,i,l={},a=Object.keys(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var c=l.a.createContext({}),s=function(e){var t=l.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=s(e.components);return l.a.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return l.a.createElement(l.a.Fragment,{},t)}},d=l.a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,r=e.parentName,c=b(e,["components","mdxType","originalType","parentName"]),p=s(n),d=i,m=p["".concat(r,".").concat(d)]||p[d]||u[d]||a;return n?l.a.createElement(m,o(o({ref:t},c),{},{components:n})):l.a.createElement(m,o({ref:t},c))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,r=new Array(a);r[0]=d;var o={};for(var b in t)hasOwnProperty.call(t,b)&&(o[b]=t[b]);o.originalType=e,o.mdxType="string"==typeof e?e:i,r[1]=o;for(var c=2;c<a;c++)r[c]=n[c];return l.a.createElement.apply(null,r)}return l.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"}}]);